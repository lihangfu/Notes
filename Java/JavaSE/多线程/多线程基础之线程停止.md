## 线程的停止

> 停止一个线程通常意味着在线程处理任务完成之前停掉正在做的操作，也就是放弃当前的操作。

在 Java 中有三种方法可以终止正在运行的线程：

1. 使用退出标志，使线程正常退出，也就是当 `run()` 方法完成后线程中止。
2. 使用 ~~`stop()`~~方法强行终止线程，不推荐，已被弃用。
3. 使用 interrupt 方法中断线程。



### 3.1 使用标志位终止线程

正常情况下，当我们的 `run()` 方法执行完毕后，线程就会终止。

但是很多情况下，我们可能让线程一直执行，比如使用循环结构来保持线程一直运行。

```java
public class MyThread extends Thread {
    // volatile修饰符用来保证其它线程读取的总是该变量的最新的值
    public volatile boolean exit = false;
    @Override
    public void run() {
        while(!exit) {
            ...
        }
    }
}
```

此时，我们就可以在外部通过修改 `exit` 的值，来使线程正常终止。

但是我们无法及时停止进行 `sleep()` 和  `wait()` 操作的线程。别问，动动脑子都知道为啥。



### 3.2 使用 `stop()` 终止线程

java.lang.Thread 类提供的方法，用来停止线程，官方都不推荐使用。

用该方法停止线程，相当于强制停止，如果线程中有 `catch ` 和 `finally `，也不会执行。

所有会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。



### 3.3 使用 `interrupt()` 中断线程

使用 `stop()` 方式停止线程是非常不安全的，而使用标志位又有限制，那我们该如何正确的停止线程？

使用 `interrupt()` 方法，需要明确的是，该方法并不会使线程直接停下，而是告诉线程，我们希望它能够停下。

我们需要在线程中，去不停的判断该值，这就好像我们第一种方式使用标志位，在循环中不停的判断该值。那我们为啥不直接使用第一种？

还记得使用标志位的问题吗？那就是无法及时停止进行 `sleep()` 和  `wait()` 操作的线程。

而使用 `interrupt()` 可以使进行 `sleep()` 和  `wait()` 操作的线程抛出 `InterruptedException` 异常，我们只需要捕获该异常进行退出前的处理就好了。



**判断线程是否被中断：**

```java
public boolean Thread.isInterrupted() //判断是否被中断
public static boolean Thread.interrupted() //判断是否被中断，并清除当前中断状态
    
```

二者在使用上的区别

比如我在循环中使用 `isInterrupted()` 判断线程中断状态，检查到中断我也不退出，之后的每次检查都是处于中断状态的，一旦遇到 `sleep()` 和  `wait()` 立马抛出异常终止。

那如果我在循环中使用`interrupted()`那，一样检查到中断我也不退出，那么只会在中断后第一次检查出中断请求，然后就会自动清除中断状态，往后的每一次都不处于中断状态，在遇到 `sleep()` 和  `wait()` 也不会停止。

`sleep()` 中中断也会清除中断状态

也就是说`isInterrupted()` 不会对中断状态进行任何改变，`interrupted()`在使用后清除中断。



**案例：**

```java
public class StopThread extends Thread {
    public StopThread(String name) {
        super(name);
    }
    @Override
    public void run() {
        try {
            // 循环中可以判断是否希望停止
            for (int i = 0; i < 100000; i++) {
                if (Thread.currentThread().isInterrupted()) throw new InterruptedException();
                System.out.println(Thread.currentThread().getName()+":资源使用--"+i);
            }
            // 睡眠
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            // 停止前统一处理，也可以在 finally 中处理
            System.out.println(Thread.currentThread().getName()+":资源关闭");
        }
    }
    public static void main(String[] args) throws InterruptedException {
        StopThread stopThread = new StopThread("A");
        stopThread.start();
        // 时间过小时在循环中判断并停止，时间长一点则由 sleep 抛出异常停止
        Thread.sleep(10000);
        stopThread.interrupt();
    }
}
```

> interrupt是将当前线程的中断标志位设置为true，具体需要线程的run方法里面自己调用isInterrupt方法判断中断标志位的值来人工决定线程中断的方式，这样做就把主动权交给了编码者，当然能够避免stop方法粗暴中断的方式。
>
> 总结一句话：线程可以忽略中断，但并不是预期的行为





