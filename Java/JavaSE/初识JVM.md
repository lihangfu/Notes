## JVM探究

* 请你谈谈你对JVM的理解？java8虚拟机和之前的变化更新？
* 什么是OOM，什么是栈溢出StackOverFlowError？怎么分析？
* JVM的常用调优参数有哪些？
* 内存快照如何抓取，怎么分析Dump文件？知道吗？
* 谈谈JVM中，类加载器你的认识？



## 1.JVM的位置

* JVM运行在操作系统之上
* JRE中包括JVM
* JRE是Java程序的运行环境
* JDK中包含了JRE，JDK是Java的开发环境





## 2.JVM的体系结构

* java文件
* ClassFile
* 类加载器（ClassLoader）
* 运行时数据区（Runtime Data Area）
  * 方法区（Method Area）也是一个堆
  * 堆（Heap）
  * Java栈（Stack）
  * 本地方法栈（Native Method Stack）
  * 程序计数器
* 执行引擎
* 本地方法接口
  * 本地方法库

![1588832013797](J:桌面文章文章图片\1588832013797.png)





## 3.类加载器

* 类：类一个抽象模板，实例才是具体的。
* 作用：加载class文件，生成模板class对象，一个类只会生成一个全局唯一的class对象。

![1588832751939](J:桌面文章文章图片\1588832751939.png)

* 分类
  * 虚拟机自带的加载器
  * 启动类（根）加载器
  * 扩展类加载器
  * 应用程序加载器



## 4.双亲委派机制

在类加载的实话：

* 类加载器收到类加载的请求
* 将这个请求向上委托给父类加载，一直向上委托，直到启动类加载器
* 启动类加载器检查是否能够加载当前类，能加载就使用当前的加载器加载，否则抛出异常，通知子类加载器加载。
* 子类继续检查，重复上诉步骤。
* 直到应用程序类加载器，还找不到加载，给用户抛出Class Not Found异常



* 作用：安全
* APP-->EXC-->BOOT
* BOOT(没有该类)-->EXC(没有该类)-->APP(加载)



* 一般系统类都由根加载器加载，双亲委派可以防止开发人员自定义系统同名类而出现bug。





## 5.沙箱安全机制

Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。沙箱机制就是将Java代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源的访问，通过这样的措施来保证代码的有效隔离，防止对系统造成破坏。

==主要限制系统资源的访问==

所有的Java程序运行都可以指定沙箱，可以定制安全策略。

Java中将执行程序分成本地代码和远程代码两种，本地默认安全，可以访问一切本地资源。



* JDK1.0中，远程代码视为不信任代码。远程代码无法访问本地资源。

* JDK1.1中增加了安全策略，允许用户指定代码对本地资源的访问权限。

* JDK1.2中改进安全机制，增加代码签名。不论本地代码还是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。

* JDK1.6(最新)，引入了域的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。

  虚拟机中不同的受保护域，对应不一样的权限。存在于不同域中的类文件就具有了当前域的全部权限。





组成沙箱的基本组件：

* 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。帮助Java程序实现内存保护。但不是所有类都会经过字节码校验，比如核心类。
* 类加载器（class loader）：其中类加载器在三个方面对Java沙箱起作用
  * 它防止恶意代码去干涉善意的代码；//双亲委派机制
  * 它守护了被信任的类库边界；
  * 它将代码归入保护域，确定了代码可以进行哪些操作。



​	虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被加载的类将有一个名字，这个命名空间是由Java细腻及为每一个类加载器维护的，它们互相之间甚至不可见。



类加载器采用的机制是双亲委派模式。



1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；
2. 由于严格通过包来区分访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。



* 存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制器的策略设定，可以由用户指定。
* 安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。
* 安全软件包（security package）：java.security下的类和扩展包下的类，运行用户为自己的应用增加新的安全特性，包括：
  * 安全提供者
  * 消息摘要
  * 数字签名
  * 加密
  * 鉴别



## 6.Native

凡是带有native关键字的，说明java的作用范围达不到了，会去调用底层c的库。



运行时会压入本地方法栈，本地方法栈通过JNI（本地方法）接口去调用本地方法库



JNI作用：扩展Java的使用，融合不同的编程语言为Java所用。

* JVM在内存区域专门开辟了一块标记区域：Native Method Stack，登记native方法。
* 在最终执行的实话，加载本地方法库中的方法通过JNI



## 7.PC寄存器

程序计数器：Program Counter Register

​	每个线程都有一个程序计数器，是线程私有的，它就是一个指针，执行方法区中的方法字节码（用来存储指向一条指令的地址，也就是即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记



## 8.方法区

Method Area

​	方法区是被所有线程共享，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，此区域属于共享区间；

​	==静态常量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关==



## 9.栈

栈：栈内存，主管程序的运行顺序，生命周期和主线程同步；

方法执行时压栈，执行完就会弹出栈，不存在垃圾回收问题。

栈：8大基本类型+对象引用+实例的方法



栈运行原理：栈帧

![1588841195874](J:桌面文章文章图片\1588841195874.png)

程序正在执行的方法，一定在栈的顶部~



## 10.堆

三种jvm虚拟机

* sun公司：HotSpot
* BEA：JRockit
* IBM：J9VM



堆：Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。



* 堆里面放对象的实例。



* 堆里的是方法引用，常量池分为静态常量池和运行时常量池，方法区里的是静态常量池，堆里的是运行时常量池



堆结构体系：

* 新生代
  * 伊甸园区（Eden Space）
  * 幸存者0区
  * 幸存者1区
* 老年代
* 元空间（1.7以前叫永久存储区）

GC垃圾回收，主要在伊甸园区和养老区。

对内存满，会出现OOM，堆内存不够的错误。



## 11.内存分配策略

* Minor GC：回收新生代，因为新生代对象存活实际很短，因此Minor GC会频繁执行，执行的速度一般也会比较快。
* FullGC：回收老年代和新生代，老年代对象其存活时间长，因此Full GC很少执行，执行速度会比Minor GC慢很多。



1. 对象优先在Eden分配

   大多数情况下，对象在新生代的伊甸园区分配，当伊甸园空间不足时，发起Minor GC。

2. 大对象直接进入老年代

   大对象是指需要连续内存空间的对象，最典型的大对象就是那种很长的字符串以及数组。

   经常出现大对象会提前触发垃圾手机以获取足够的连续空间分配给大对象。

    -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 

3. 长期存活的对象进入老年代

   为对象定义年龄计数器，对象在伊甸园区出生并经过Minor GC依然存活，将移动到幸存者区，年龄就增加1岁，增加到一定年龄则移动到老年代中。

    -XX:MaxTenuringThreshold 用来定义年龄的阈值。 

4. 动态对象年龄判定

   虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 

5. 空间分配担保

   在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

   如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

